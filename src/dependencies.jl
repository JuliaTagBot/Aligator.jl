using SymPy
using Nemo
using ContinuedFractions
using ArraySlices # used for convenience functions for iterating rows of matrices

# represents the algebraic number in the field Q[theta] given by c0 + c_1 theta + ...
struct AlgebraicNumber
    theta::Sym
    coeffs::Array{Sym, 1}
end

function polyrepr(x, coeffs)
   return sum([c*x^(i-1) for (i, c) in enumerate(coeffs)]) 
end

function poly(a::AlgebraicNumber)
    return polyrepr(a.theta, a.coeffs)
 end

function Base.show(io::IO, a::AlgebraicNumber)
    print(io, "[$(a.theta), $(a.coeffs)] $(expand(polyrepr(a.theta, a.coeffs)))")
end

function common_number_field(extensions::Array{Sym, 1})
    nonrat = filter(ext -> (is_rational(ext) == false), extensions)
    if isempty(nonrat)
        theta = 1
    else
        minpoly, coeffs = primitive_element(Sym(PyCall.array2py(nonrat)))
        theta = dot(nonrat, coeffs)
    end
    return [AlgebraicNumber(theta, field_isomorphism(ext, theta)) for ext in extensions]
end

function z_nullspace(matrix::Matrix{Int})
    h, t = hnf_with_transform(matrix)
    
    # kernel is generated by the rows of t that correspond to zero rows in h
    zvec = zeros(size(h, 2))

    # TODO: find better way to filter zero vectors
    res = Matrix{Int}(0, ncols(t))
    for i in 1:nrows(t)
        if iszero(h[i,:])
            res = vcat(res, transpose(t[i,:]))
        end
    end
    return res
    # return [t[i,:] for i in 1:size(h, 1) if h[i,:] == zvec]
end

function z_module_intersect(base1::Matrix{Int}, base2::Matrix{Int})
    if isempty(base1) || isempty(base2)
        return []
    end

    sol = z_nullspace(vcat(base1, base2))

    if isempty(sol)
        return []
    end

    m1 = transpose(base1)
    m2 = transpose(sol[:, 1:nrows(base1)])
    return lll(transpose(m1 * m2))
end

function minimal_polynomial(a::AlgebraicNumber, x::Sym)
    return SymPy.minimal_polynomial(poly(a), x)
end

function masser_bound(roots::Array{AlgebraicNumber, 1})
    k = length(roots)
    # assume all roots belong to the same number field
    @syms x
    p = Poly(SymPy.minimal_polynomial(roots[1].theta, x), x)
    d = SymPy.degree(p) #TODO: degree of field extension

    # h = maximum height of the a[i]. The height of an algebraic number is the 
    # sum of the degree and the binary length of all coefficients in the 
    # defining equation over Q
    h = 0
    for root in roots
        p = Poly(minimal_polynomial(root, x), x)
        h0 = ceil(SymPy.degree(p) + sum([SymPy.log(abs(ex)) for ex in coeffs(p)]))
        println("h0: ", h0)
        if h0 > h
            h = h0
        end
    end
    println("d: ", d)
    println("h: ", h)
    println("k: ", k)

    return ceil(d^2 * (4*h*k*d* (SymPy.log(2+d)/SymPy.log(SymPy.log(2+d)))^3)^(k-1) + 1)
end

# workaround since findin(...) does not work for Sym(0) for some reason
function findzeros(a::Array{Sym,1})
    zeros = []
    for i in eachindex(a)
        if a[i] == Sym(0)
            zeros = [zeros; i]
        end
    end
    return zeros
end

function findrelations(roots::Array{Sym,1})
    # first treat zeros in the root list
    zeros = find(x -> x == 0, roots)
    if length(zeros) == length(roots)
        return []
    end
    if !isempty(zeros)
        B = findrelations(dropzeros(roots))
        # TODO: insert new dimensions
        return B
    end

    an = common_number_field(roots) # TODO: does nothing if the roots belong to the same field
    a = poly.(an)

    println("ABC: ", a)
    relog = [SymPy.real(SymPy.log(Sym(x))) for x in a]
    imlog = [SymPy.imag(SymPy.log(Sym(x))) for x in a]
    imlog = [imlog; 2*SymPy.pi]

    println(relog)
    println(imlog)

    # replace implicit zeros by explicit ones
    for i in 1:length(a)
        z = a[i]

        # abs(z) == 1
        if abs(N(abs(z)) - 1) < 0.1 && simplify(abs(z)) == 1
            relog[i] = 0
        end

        # z is real and z >= 0
        if is_real(z) && is_real(sqrt(z))
            imlog[i] = 0
        else
            # TODO: try harder: If[ Element[RootReduce[z], Reals] && Element[Sqrt[RootReduce[z]], Reals], imLog[[i]] = 0 ];
        end
    end

    # comute a bound for the coefficients of the generators
    bound = Int(masser_bound(an))
    println("Masser bound: ", bound)

    m = eye(Int, length(a)) # identity matrix

    # successively refine the approximation until only valid generators are returned
    level = Int(ceil(N(log(bound, 2)) + 1))
    while prod([check_relation(a, m[i,:]) for i in 1:size(m)[1]]) == 0
        println("level: $(level), bound: $(bound)")
        println(relog)
        m1 = getbasis(relog, level, bound)
        println("basis: ", m1)
        println(imlog)
        m2 = getbasis(imlog, level, bound)
        # m2 = view(m2, :, 1:size(m2)-1)
        println("ABNCD")
        println(m2)
        m = z_module_intersect(m1, m2[:,1:end-1])
    end

    return m
end

check_relation(a::Array{Sym, 1}, e::Array{Int, 1}) = prod([ax^ex for (ax, ex) in zip(a,e)]) == 1

function convergent(x, n)
    cf = ContinuedFraction(Rational(x))
    co = convergents(cf)
    res = next(co, n)[1]
    println("type: ", typeof(res))
    return next(co, n)[1]
end

nrows(a::Matrix{<:Any}) = size(a)[1]
ncols(a::Matrix{<:Any}) = size(a)[2]

function getbasis(l::Array{Sym, 1}, level::Int, bound::Int)
    n = length(l)

    # first treat zero elements in l as special case
    # zeros = find(x -> x == 0, l)
    zpos = findzeros(l)
    if length(zpos) == length(l)
        return eye(Int, n)
    end

    if length(zpos) > 0
        # ex = findzeros(l)
        println("zeros: ")
        println(zpos)
        ll = deleteat!(l, zpos)
        println("nonzero elements:")
        println(ll)
        b = getbasis(ll, level, bound) # basis for nonzero numbers
        println(nrows(b))
        zvec = zeros(nrows(b), 1)
        println(zvec)
        # insert new dimensions
        for pos in zpos
            b = hcat(b[:,1:pos-1], zvec, b[:,pos:end])
        end
        # add unit vectors at the zero positions
        b = vcat(b, eye(n)[zpos,:])

        return Matrix{Int}(b)
    end

    # now we assume that l is a list of nonzero real numbers
    c1 = [convergent(x, level) for x in l]
    c2 = [convergent(x, level+1) for x in l]

    println("c1: ", c1)

    e = [1/denominator(x1*x2) for (x1, x2) in zip(c1, c2)]
    # cfrac theorem says: | log[i] - c1[i] | <= e[i]

    # refine the approximation such that all errors are smaller than the smallest
    # element of l in absolute value *)

    lev = level + 1
    while length(filter(x -> maximum(e) >= abs(x), c1)) > 0 && lev < level + 5
        ex = findin(e, maximum(e)) # indices with greates error

        lev++
        for i in 1:length(ex)
            j = ex[i]
            c1[j] = c2[j]
            c2[j] = convergent(l[j], lev)
            e[j] = c1[j] == l[j] ? 0 : 1/denominator(c1[j]*c2[j])
        end
    end

    # now: max e[i] < min |c1[i]|

    # this bound guarantees that generators whose norm is at most bound will
    # appear in the LLL-reduced basis
    minc1 = minimum([abs(c) for c in c1])
    maxe = maximum([abs(c) for c in e])
    d = Int(ceil(float(((length(c1) - 1)/2)*bound/(minc1 - maxe))))

    identity = eye(Int, n)
    println(typeof(identity))
    println(c1)
    row = c1 * d
    println(row)
    b = hcat(identity, row)
    println(typeof(b))
    b = lll(b)
    println("lll: ", b, " type: ", typeof(b))
    # Vectors whose right hand side is greater than the errors permit can be 
    #   discarded; they cannot correspond to integer relations.
    # b = vcat([b[i,:] for i in 1:nrows(b) ])
    # TODO: find better way to filter rows
    res = Matrix{Rational{Int}}(0,n+1)
    for i in 1:nrows(b)
        if (abs(b[i,:][end]) <= d*abs(dot(b[i,1:n],e)))
            res = vcat(res, transpose(b[i,:]))
        end
    end
    println("lll: ", res, " type: ", typeof(res))
    # b = filter(x -> ))

    # all remaining vectors are returned as candidates
    # TODO: result should be integer matrix?
    return Matrix{Int}(res[:,1:end-1])
end

function clear_denom(a::Matrix{Rational{Int64}})
    d = lcm(denominator.(a))
    println("d: $(d)")
    println(a)
    return a*d, d
end

function lll(a::Matrix{Rational{Int64}})
    m, d = clear_denom(a)
    m = Int.(a)
    println(typeof(m))
    m = Matrix{Int}(Nemo.lll(matrix(FlintZZ, m)))
    return m // d
end

lll(m::Matrix{Int}) = Matrix{Int}(Nemo.lll(matrix(FlintZZ, m)))

hnf_with_transform(m::Matrix{Int}) = Matrix{Int}.(Nemo.hnf_with_transform(matrix(FlintZZ, m)))

z1 = Sym((1+sqrt(Sym(5)))/2)
z2 = Sym((1-sqrt(Sym(5)))/2)
z3 = Sym(-1)

e1 = Sym(2)
e2 = Sym(1/Sym(2))

result = findrelations([e1,e2])
println("Relations: ")
println(result)