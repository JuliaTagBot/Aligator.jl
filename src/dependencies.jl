using SymPy

function z_nullspace(matrix)
    h, t = hnf_with_transform(matrix)
    
    # kernel is generated by the rows of t that correspond to zero rows in h
    zeros = zeros(size(h, 2))
    return [t[i,:] for i in 1:size(h, 1) if h[i,:] == zeros]
end

function z_module_intersect(base1, base2)
    if isempty(base1) || isempty(base2)
        return []
    end

    sol = z_nullspace(vcat(base1, base2))

    if isempty(sol)
        return []
    end

    m1 = transpose(base1)
    m2 = transpose(view(sol, :, 1:size(base1)))
    return lll(transpose(dot(m1, m2)))
end

function masser_bound(roots)
    k = length(roots)
    # assume all roots belong to the same number field
    d = 0 #TODO: degree of field extension

    # h = maximum height of the a[i]. The height of an algebraic number is the 
    # sum of the degree and the binary length of all coefficients in the 
    # defining equation over Q
    h = 0
    @sym x
    for root in roots
        p = minimal_polynomial(root, x)
        h0 = ceil()
    end
end

function findrelations(roots::Array{Sym,1})
    # first treat zeros in the root list
    zeros = find(x -> x == 0, roots)
    if length(zeros) == length(roots)
        return []
    end
    if !isempty(zeros)
        B = findrelations(dropzeros(roots))
        # TODO: insert new dimensions
        return B
    end

    a = to_number_field(Sym(PyCall.array2py(roots))) # does nothing if the roots belong to the same field

    println(a, typeof(a))
    relog = [SymPy.real(SymPy.log(Sym(x))) for x in a]
    imlog = [SymPy.imag(SymPy.log(Sym(x))) for x in a]

    println(relog)
    println(imlog)

    # replace implicit zeros by explicit ones
    for i in 1:length(a)
        z = a[i]

        # abs(z) == 1
        if abs(N(abs(z)) - 1) < 0.1 && simplify(abs(z)) == 1
            relog[i] = 0
        end

        # z is real and z >= 0
        if is_real(z) && is_real(sqrt(z))
            imlog[i] = 0
        end
    end

    # comute a bound for the coefficients of the generators
    bound = masser_bound(a)

    m = eye(length(a)) # identity matrix

    # successively refine the approximation until only valid generators are returned
    level = ceil(N(log(bound, 2)) + 1)
    while prod([check_relation(a, x) for x in m]) == 0
        m1 = getbasis(relog, level, bound)
        m2 = getbasis(imlog, level, bound)
        m2 = view(m2, :, 1:size(m2)-1)
        m = z_module_intersect(m1, m2)
    end

    return m
end

check_relation(a::Array{Sym}, e::Array{Sym}) = prod([ax^ex for (ax, ex) in zip(a,e)]) == 1




z1 = Sym((1+sqrt(Sym(5)))/2)
z2 = Sym((1-sqrt(Sym(5)))/2)
z3 = Sym(-1)

findrelations([z1,z2,z3])